---
title: "Optimal Transport Conditional Flow Matching - æ‹¡æ•£ãƒ¢ãƒ‡ãƒ«ã«å–ã£ã¦ä»£ã‚ã‚‹æ¬¡ä¸–ä»£ã®ç”ŸæˆæŠ€è¡“ï¼Ÿ" # è¨˜äº‹ã®ã‚¿ã‚¤ãƒˆãƒ«
emoji: "ğŸ˜¸" # ã‚¢ã‚¤ã‚­ãƒ£ãƒƒãƒã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹çµµæ–‡å­—ï¼ˆ1æ–‡å­—ã ã‘ï¼‰
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢è¨˜äº‹
topics: ["æ©Ÿæ¢°å­¦ç¿’", "è«–æ–‡è§£èª¬", "æ‹¡æ•£ãƒ¢ãƒ‡ãƒ«", "FlowMatching"] # ã‚¿ã‚°ã€‚["markdown", "rust", "aws"]ã®ã‚ˆã†ã«æŒ‡å®šã™ã‚‹
published: false # å…¬é–‹è¨­å®šï¼ˆfalseã«ã™ã‚‹ã¨ä¸‹æ›¸ãï¼‰
publication_name: "fusic"
---

ã“ã‚“ã«ã¡ã¯ï¼[Fusic](https://fusic.co.jp/) æ©Ÿæ¢°å­¦ç¿’ãƒãƒ¼ãƒ ã®é·²å´ã§ã™ã€‚æœ€è¿‘ã€éŸ³å£°ã‚„è¨€èªå‡¦ç†ã«èˆˆå‘³ãŒã‚ã‚Šã¾ã™ãŒã€æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«ã®é–‹ç™ºã‹ã‚‰é‹ç”¨ã¾ã§ãªã‚“ã§ã‚‚ã—ã¦ã„ã¾ã™ã€‚ã‚‚ã—ã€æ©Ÿæ¢°å­¦ç¿’ã§å›°ã£ã¦ã„ã‚‹ã“ã¨ãŒã‚ã‚Œã°ã€æ°—è»½ã«[DM](https://twitter.com/kwashizzz)ãã ã•ã„ã€‚

æœ¬è¨˜äº‹ã§ã¯ã€Flow Matching (FM)ã¨ã€ãã®ç™ºå±•ç‰ˆã§ã‚ã‚‹Optimal Transport Conditional Flow Matching (OT-CFM)ã‚’è§£èª¬ã—ã¾ã™ã€‚æœ€è¿‘ã®ç”ŸæˆAIã§ã¯ã€æ‹¡æ•£ãƒ¢ãƒ‡ãƒ«ãŒã‚ˆãä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™ãŒã€Flow Matchingã¯ã€æ‹¡æ•£ãƒ¢ãƒ‡ãƒ«ã«å–ã£ã¦ä»£ã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ç”ŸæˆæŠ€è¡“ã¨è€ƒãˆã¦ã„ã¾ã™ã€‚

ãŠã‚‚ã«ã€[Improving and Generalizing Flow-Based Generative Models with Minibatch
Optimal Transport](https://arxiv.org/abs/2302.00482)ã¨ã„ã†è«–æ–‡ã‚’å‚è€ƒã«è§£èª¬ã—ã¦ã„ããŸã„ã¨æ€ã„ã¾ã™ã€‚ã¾ãŸã€æœ¬è¨˜äº‹ã®å›³ã¯ã€ã“ã®è«–æ–‡ã‹ã‚‰å‚ç…§ã„ãŸã—ã¾ã—ãŸã€‚

Flow Matachingã¯ã€éŸ³å£°åˆæˆç•Œéšˆã§ã¯ã€MetaãŒç™ºè¡¨ã—ãŸéŸ³å£°åˆæˆæ‰‹æ³•ã§ã‚ã‚‹[Voicebox](https://voicebox.metademolab.com/)ã‚„ã€ã‚ˆã‚Šé«˜é€Ÿã§é«˜æ€§èƒ½ãªéŸ³å£°åˆæˆæ‰‹æ³•ã§ã‚ã‚‹[Matcha-TTS](https://arxiv.org/abs/2309.03199)ã«ä½¿ç”¨ã•ã‚Œã¦ãã¦ã„ã¾ã™ã€‚
Matcha-TTSã«é–¢ã—ã¦ã¯ã€å¼Šç¤¾ã®ToshikiãŒã€è¨˜äº‹ã‚’æ›¸ã„ã¦ã„ã‚‹ã®ã§ã€ãœã²ã€èª­ã‚“ã§ã¿ã¦ãã ã•ã„ã€‚

[ã€éŸ³å£°åˆæˆã€‘Matcha-TTSğŸµã§æ—¥æœ¬èªéŸ³å£°ã‚’ç”Ÿæˆã—ã¦ã¿ã‚‹](https://zenn.dev/fusic/articles/bd7da12adf5901)

å€‹äººçš„ã«ã€Flow Matchingã¯ã€æ‹¡æ•£ãƒ¢ãƒ‡ãƒ«ãŒç™ºå±•ã—ãŸæ‰‹æ³•ã¨è€ƒãˆã¦è«–æ–‡ã‚’èª­ã¿å§‹ã‚ãŸã®ã§ã™ãŒã€ãã‚Œã ã¨ã‹ãªã‚Šå‹˜é•ã„ã—ã¦ã—ã¾ã£ã¦ã„ã¾ã—ãŸã€‚
çš†ã•ã‚“ã€Normalize Flowã¨ã„ã†æ‰‹æ³•ã‚’èã„ãŸã“ã¨ãŒã‚ã‚Šã¾ã™ã§ã—ã‚‡ã†ã‹ï¼Ÿç¾åœ¨ã€æ‹¡æ•£ãƒ¢ãƒ‡ãƒ«ãŒãƒã‚ºãƒ¯ãƒ¼ãƒ‰åŒ–ã—ã™ãã¦ã€ã‚ã¾ã‚Šè€³ã«ã—ãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€åˆ†å¸ƒã‚’å¤‰æ›ã™ã‚‹é–¢æ•°ã‚’å­¦ç¿’ã™ã‚‹ã¨ã¦ã‚‚ãŠã‚‚ã—ã‚ã„ãƒ¢ãƒ‡ãƒ«ã§ã™ã€‚ãã®Normalize Flowã®ç™ºå±•ç‰ˆãŒFlow Matchingã¨è€ƒãˆã‚‹ã¨ã‚¹ãƒ ãƒ¼ã‚ºã«ç´å¾—ã§ããŸæ°—ãŒã—ã¾ã™ã€‚
ãã“ã§ã€æœ¬è¨˜äº‹ã§ã¯ã€æ‹¡æ•£ãƒ¢ãƒ‡ãƒ«ã¨Normalize Flowã®é–¢ä¿‚æ€§ã‹ã‚‰Flow Matchingã¾ã§ã®éç¨‹ã¨ãã®ç™ºå±•ã‚’è§£èª¬ã—ã¦ã„ããŸã„ã¨æ€ã„ã¾ã™ã€‚

ç†è§£ãŒåŠã°ãªã‹ã£ãŸéƒ¨åˆ†ãŒå¤šã€…ã‚ã‚‹ãŸã‚ã€ã”æŒ‡æ‘˜ã‚’ãŸãã•ã‚“ã„ãŸã ã‘ã‚‹ã¨å¬‰ã—ã„ã§ã™ã€‚ã‚ˆã‚ã—ããŠé¡˜ã„ã„ãŸã—ã¾ã™ã€‚

# åŸºç¤

Flow Matchingã‚’ç†è§£ã™ã‚‹ãŸã‚ã«ã€ã¾ãšã€æ‹¡æ•£ãƒ¢ãƒ‡ãƒ«ã®æ‹¡æ•£éç¨‹ã‚’é€£ç¶šæ™‚é–“åŒ–ã—ãŸã€ç¢ºç‡å¾®åˆ†æ–¹ç¨‹å¼(SDE)ã‚’èª¬æ˜ã—ã¾ã™ã€‚
ãã—ã¦ã€ãã‚Œã‚’å¸¸å¾®åˆ†æ–¹ç¨‹å¼(ODE)ã«å¤‰æ›ã—ãŸç¢ºç‡ãƒ•ãƒ­ãƒ¼ODEã‚’èª¬æ˜ã—ã¾ã™ã€‚

ãã®å¾Œã€ç¢ºç‡ãƒ•ãƒ­ãƒ¼ODEãŒã€Normalize Flow (NF)ã‚’é€£ç¶šåŒ–ã—ãŸContinuous Normalize Flow (CNF)ã¨ã€ã©ã®ã‚ˆã†ã«é–¢é€£ã™ã‚‹ã‹èª¬æ˜ã—ã¾ã™ã€‚

SDEã¨ODEã®è©³ç´°ã«é–¢ã—ã¦ã¯ã€[æ‹¡æ•£ãƒ¢ãƒ‡ãƒ« ãƒ‡ãƒ¼ã‚¿ç”ŸæˆæŠ€è¡“ã®æ•°ç†](https://www.amazon.co.jp/dp/400006343X)ã¨ã„ã†æœ¬ãŒã¨ã¦ã‚‚å‚è€ƒã«ãªã‚Šã¾ã™ï¼ãœã²èª­ã‚“ã§ã¿ã¦ãã ã•ã„ã€‚

## æ‹¡æ•£ãƒ¢ãƒ‡ãƒ«ã®ç¢ºç‡å¾®åˆ†æ–¹ç¨‹å¼(SDE)

æ‹¡æ•£ãƒ¢ãƒ‡ãƒ«ã§ã¯ã€æ‹¡æ•£ãƒ»é€†æ‹¡æ•£éç¨‹ã®ã‚¹ãƒ†ãƒƒãƒ—æ•°ã‚’å¢—ã‚„ã›ã°å¢—ã‚„ã™ã»ã©ã€é›¢æ•£åŒ–èª¤å·®ãŒå°ã•ããªã‚Šç”Ÿæˆæ€§èƒ½ãŒå‘ä¸Šã—ã¾ã™ã€‚
ãã“ã§ã€ã‚¹ãƒ†ãƒƒãƒ—æ•°ã‚’ç„¡é™å¤§ã«å¢—ã‚„ã—ã¦é€£ç¶šåŒ–ã—ãŸå ´åˆã®æ‹¡æ•£ãƒ¢ãƒ‡ãƒ«ã‚’è€ƒãˆã€ã“ã®ãƒ¢ãƒ‡ãƒ«ã¯ç¢ºç‡å¾®åˆ†æ–¹ç¨‹å¼(SDE)ã¨ã¿ãªã™ã“ã¨ãŒã§ãã¾ã™ã€‚

æ‹¡æ•£éç¨‹ã«ç›¸å½“ã™ã‚‹æ‹¡æ•£SDEã¯ã€ä»¥ä¸‹ã®å¼ã§ä¸ãˆã‚‰ã‚Œã¾ã™ã€‚

$dx = f(x, t)dt + g(t)dw$

$dx$ã¯ãƒ‡ãƒ¼ã‚¿$x$ã®å¾®å°æ™‚é–“ã‚ãŸã‚Šã®å¤‰åŒ–é‡ã§ã™ã€‚ã“ã®å¤‰åŒ–é‡ã¯ã€æ±ºå®šçš„ã«å¤‰åŒ–ã™ã‚‹é‡$f(x, t)dt$ã¨ã€ãƒ©ãƒ³ãƒ€ãƒ ã«å¤‰åŒ–ã™ã‚‹é‡$g(t)dw$ã‹ã‚‰ãªã‚Šã¾ã™ã€‚$f(x, t)$ã¯ã€ãƒ‡ãƒ¼ã‚¿$x$ã¨æ™‚åˆ»$t$ã§æ±ºã¾ã‚Šã¾ã™ã€‚ã¾ãŸã€$w$ã¯ã€æ¨™æº–ã‚¦ã‚£ãƒ¼ãƒŠãƒ¼éç¨‹ã¨å‘¼ã°ã‚Œã€$dw$ã¯ã€å¾®å°æ™‚é–“é–“éš”$\tau$ã«ãŠã„ã¦ã€å¹³å‡$0$ã€åˆ†æ•£$\tau$ã¨ãªã‚‹æ­£è¦åˆ†å¸ƒã§ã™ã€‚

ä¸€æ–¹ã§ã€é€†æ‹¡æ•£éç¨‹ã¯ã€ä»¥ä¸‹ã®SDEã§ä¸ãˆã‚‰ã‚Œã¾ã™ã€‚

$dx = f(x, t) -  (t)  (x) dt + g(t) d$

$dx = [ f(x, t) - g^2(t) \nabla_x \rm{log} p_t (x) ] dt + g(t) d \bar{w}$

æ™‚åˆ»$t$ã®ã‚¹ã‚³ã‚¢$\nabla_x \rm{log} p_t (x)$ãŒã€ã‚ã‹ã‚Šã•ãˆã™ã‚Œã°ã€äº‹å‰åˆ†å¸ƒ$p_T(x)$ã‹ã‚‰ã€ãƒ‡ãƒ¼ã‚¿åˆ†å¸ƒ$p_0(x)$ã¸ã®å¤‰æ›çµŒè·¯ã‚’æ±‚ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

### ä¾‹ãˆã°ã€Denoising Diffusion Probabilistic Model (DDPM)ã®å ´åˆã€ä»¥ä¸‹ã®ã‚ˆã†ãªSDEã«ãªã‚Šã¾ã™ã€‚

å…ƒã®DDPMã®å¼ã¯ã€ä»¥ä¸‹ã§ã™ã€‚

$x_{t+1} = \sqrt{1 - \beta_{t}}x_{i-1} + \sqrt{\beta_i} z_{i-1}  $

ã“ã®å¼ã‚’ã€SDEã«ã—ãŸDDPMã®å¼ã¯ä»¥ä¸‹ã§ã™ã€‚

$dx = -\frac{1}{2}\beta(t)xdt + \sqrt{\beta(t)}dw$

ã“ã“ã§ã®ã€$\beta$ã¯ã€ãƒã‚¤ã‚ºã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§ã™ã€‚

## ç¢ºç‡ãƒ•ãƒ­ãƒ¼å¸¸å¾®åˆ†æ–¹ç¨‹å¼ (ODE)

ä»»æ„ã®SDEã¯ã€åŒã˜å‘¨è¾ºåˆ†å¸ƒ$\lbrace p_t(x) \rbrace_{t\in \lbrack 0,T \rbrack}$ã‚’æŒã¤å¸¸å¾®åˆ†æ–¹ç¨‹å¼(ODE)ã«å¤‰æ›ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚SDEã®æ‹¡æ•£éç¨‹ãƒ»é€†æ‹¡æ•£éç¨‹ã¯ã€ä»¥ä¸‹ã®å¼ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚

$dx = \lbrack f(x, t) - \frac{1}{2}g^2(t) \nabla_x \rm{log} p_t (x) \rbrack dt$

ç¢ºç‡çš„ãªè¦ç´ ãŒé™¤å¤–ã•ã‚Œã€æ‹¡æ•£éç¨‹ã§ã¯$dx$, é€†æ‹¡æ•£éç¨‹ã§ã¯$-dx$ã®ã‚ˆã†ã«ã€åŒã˜å¼ã§å–ã‚Šæ‰±ã†ã“ã¨ãŒã§ãã¾ã™ã€‚

## Normalizing Flow

Normalizing Flow (NF)ã¯ã€è¤‡é›‘ãªåˆ†å¸ƒã‚’ã€ã‚ˆã‚Šå˜ç´”ãªåˆ†å¸ƒã¸å¤‰æ•°å¤‰æ›ï¼ˆNormalize)ã™ã‚‹é–¢æ•°ã®ã“ã¨ã§ã™ã€‚

ä¾‹ãˆã°ã€ã‚·ãƒ³ãƒ—ãƒ«ãªç¢ºç‡å¯†åº¦é–¢æ•°$p_Z(z)$ã¨ã€è¤‡é›‘ãªç¢ºç‡å¯†åº¦é–¢æ•°$p_Y(y)$ã®é–“ã®å¤‰æ•°å¤‰æ›ã‚’è¡Œã†ã¨ã—ã¾ã™ã€‚ãã®ã¨ãã€$y$ã‹ã‚‰$z$ã¸ã®å¤‰æ•°å¤‰æ›ã‚’$z=f(y)$ã¨ã—ãŸã¨ãã€$p_Y(y)$ã¯ã€ä»¥ä¸‹ã®å¼ã§è¡¨ã›ã¾ã™ã€‚

$p_Y(y) = p_Z(z) | \frac{\partial f}{\partial y} |$

NFã§ã¯ã€ã“ã®å¤‰æ•°å¤‰æ›ã‚’è¡Œã†é–¢æ•°$f$ã¯ã€å¯é€†ã§ã‚ã‚‹ã¨ã„ã†æ€§è³ªã‚’æº€ãŸã—ã¾ã™ã€‚

$g = f^{-1}$

ã¾ãŸã€NFã§ã¯ã€ã“ã®æ€§è³ªã‚’ã‚‚ã¤é–¢æ•°$f_i$ã«ã‚ˆã‚‹åˆæˆé–¢æ•°ã§ã€å¤‰æ•°å¤‰æ›ã®å¼ã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚

$f = f_1 \circ f_2 \circ \dots \circ f_N$

$g = f^{-1} = f^{-1}_N \circ \dots \circ f^{-1}_1$

ã–ã£ãã‚Šã—ãŸã‚¤ãƒ¡ãƒ¼ã‚¸ã§ã™ãŒã€$f_i$ã§å¾ã€…ã«åˆ†å¸ƒã‚’å¤‰æ›ã—ã¦ã„ãã®ãŒã€ãƒã‚¤ã‚ºã‚’é™¤å»ã—ã¦ã„ãæ‹¡æ•£ãƒ¢ãƒ‡ãƒ«ã«ä¼¼ã¦ã„ã‚‹æ°—ãŒã—ã¾ã—ãŸï¼ï¼

## Continuous Normalizing Flow

[Neural Ordinary Differential Equations (Neural ODE)](https://arxiv.org/abs/1806.07366) ã¨ã„ã†è«–æ–‡ã§ã€é€£ç¶šæ™‚é–“åŒ–ã—ãŸNormalizing Flow ã‚’ Continuous Normalizing Flow (CNF)ã¨å‘¼ã‚“ã§ã„ã¾ã—ãŸã€‚

Neural ODEã§ã¯ã€Residual Networkã®ã‚ˆã†ã«ã€æ®‹å·®ã‚’è¨ˆç®—ã®çµæœã‚’å…ƒã®å€¤ã«ä»˜åŠ ã™ã‚‹ã“ã¨ã§å€¤ã‚’æ›´æ–°ã™ã‚‹æ–¹æ³•ã«ç€ç›®ã—ã€ä»¥ä¸‹ã®ã‚ˆã†ã«å¸¸å¾®åˆ†æ–¹ç¨‹å¼ã®å¼ã«ä¼¼ãŸæ¦‚å¿µã‚’å°å…¥ã—ã¦ã„ã¾ã™ã€‚

$x_{t+1} = x_t + \frac{df(x)}{dt} = x_t + f(x, t)$

ã“ã®è¡¨ç¾ã‚’ç”¨ã„ã‚‹åˆ©ç‚¹ã¯ã€å¤‰åŒ–é‡ã®å¾®åˆ†ã‚’è¡¨ã™å˜ä¸€ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’ä½¿ç”¨ã™ã‚Œã°ã‚ˆãã€ãƒ¡ãƒ¢ãƒªã®ä½¿ç”¨é‡ã‚’å‰Šæ¸›ã§ãã¾ã™ã€‚åŠ ãˆã¦ã€é€†å¤‰æ›ã®è¨ˆç®—ãŒå¯èƒ½ã§ã€RNNãªã©é›¢æ•£çš„ãªæ™‚é–“ã‚’æ‰±ã†ãƒ¢ãƒ‡ãƒ«ã¨ã¯ã“ã¨ãªã‚Šã€é€£ç¶šæ™‚é–“ã‚’æ‰±ã†ã“ã¨ãŒã§ãã¾ã™ã€‚

â€»ã€€ã“ã‚Œã®ç‰¹æ®Šç³»ãŒç¢ºç‡ãƒ•ãƒ­ãƒ¼ODEã«ãªã‚Šã¾ã™ã€‚

**ã“ã‚Œã‚’ã€CNFã«ç™ºå±•ã•ã›ãŸã‚‚ã®ãŒä»¥ä¸‹ã«ãªã‚Šã¾ã™ã€‚**

ã“ã®Neural ODEã®è€ƒãˆã§ã€Normalizing Flowã‚’å–ã‚Šæ‰±ã†ã¨ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ã€ç¢ºç‡å¤‰æ•°$x_0$ã‹ã‚‰$x_1$ã®å¤‰åŒ–ã‚’ã€é€£ç¶šæ™‚é–“ã®å¤‰åŒ–é‡ã®ç©åˆ†ã§æ“ä½œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

$x_1 = x_0 + \int^{t_1}_{t_0} f(x(t), t) dt$

ã“ã®å¾®åˆ†ã¯ã€$dx/dt = f(x(t), t)$ã§ã€ã©ã®æ™‚é–“$t$ã«ãŠã„ã¦ã‚‚ã€$f(x(t), t)$ã¨ã„ã†å˜ä¸€ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã§è¡¨ç¾ã•ã‚Œã¦ã„ã¾ã™ã€‚

ã¾ãŸã€ã“ã®å¤‰æ›ã®é€†å¤‰æ›ã‚‚ã€ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚

$x_0 = x_1 + \int^{t_0}_{t_1} f(x(t), t) dt$

ä¸Šè¨˜ã®ã“ã¨ã‹ã‚‰ã€æ‹¡æ•£ãƒ¢ãƒ‡ãƒ«ã®æ‹¡æ•£éç¨‹ã¨é€†æ‹¡æ•£éç¨‹ã«é¡ä¼¼ã—ãŸè¡¨ç¾ã‚’ã™ã‚‹ã¨ã€æ‹¡æ•£éç¨‹ã«ã‚ãŸã‚‹ODEã¯ã€

$dx = f(x, t) dt$

ã¨ãªã‚Šã€é€†æ‹¡æ•£éç¨‹ã«ã‚ãŸã‚‹ODEã¯ã€

$dx = -f(x, t) dt$

ã®ã‚ˆã†ã«è¡¨ç¾ã§ãã¾ã™ã€‚

## ãªãœã€æ‹¡æ•£ãƒ¢ãƒ‡ãƒ«ãŒã‚ˆã„ã¨ã•ã‚Œã¦ã„ã‚‹ã®ã‹ï¼Ÿ

æ‹¡æ•£ãƒ¢ãƒ‡ãƒ«ã®DDPMã®æå¤±ã¯ã€ä»¥ä¸‹ã«ãªã‚Šã¾ã™ã€‚

$\rm{E}_{t, q(z), p_t(x|z)} || s_{\theta}(t, x) - \nabla_x \rm{log} p_t(x|z)||^2_2$

ã“ã‚Œã‹ã‚‰åˆ†ã‹ã‚‹é€šã‚Šã€æ‹¡æ•£ãƒ¢ãƒ‡ãƒ«ã¯ã€å„æ™‚åˆ»ã”ã¨ã®ç”Ÿæˆéç¨‹ã‚’ç‹¬ç«‹ã§å­¦ç¿’å¯èƒ½ã§ã™ã€‚ã“ã‚Œã¯ã€è¤‡æ•°ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’ç¹°ã‚Šè¿”ã™ã“ã¨ã§å·¨å¤§ãªè¨ˆç®—éç¨‹ã‚’å­¦ç¿’ã§ãã€ã‹ã¤ã€è¨ˆç®—ã‚°ãƒ©ãƒ•ã®ä¸€éƒ¨åˆ†ã‚’æŠœãå‡ºã—ã¦å­¦ç¿’ã§ãã‚‹ã¨ã„ã†åˆ©ç‚¹ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ã‚ˆã†ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’Simulation Freeã¨å‘¼ã³ã¾ã™ã€‚

ä¸€æ–¹ã§ã€CNFã®æå¤±ã¯ã€ä»¥ä¸‹ã«ãªã‚Šã¾ã™ã€‚

$ \rm{E}_{q(x_1)} \lbrack \rm{log} p_0(x_0) - \int \rm{Tr}(\frac{\partial f}{\partial x_t}) dt \rbrack$

è¦‹ã¦ã®é€šã‚Šã§ã™ãŒã€å…¨æ™‚åˆ»ã«æ¸¡ã£ã¦ç©åˆ†ã—ãŸå€¤ã‚’ä½¿ç”¨ã—ã¦ãŠã‚Šã€è¨ˆç®—ã‚°ãƒ©ãƒ•ã®ã™ã¹ã¦ã‚’ä½¿ã£ã¦å­¦ç¿’ãŒå¿…è¦ã¨ãªã‚‹æ¬ ç‚¹ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ã‚ˆã†ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯ã€Simulation based trainingã¨å‘¼ã°ã‚Œã¾ã™ã€‚ã“ã‚ŒãŒåŸå› ã§ã€å­¦ç¿’åŠ¹ç‡ãŒæ‚ªãã€æ‹¡æ•£ãƒ¢ãƒ‡ãƒ«ã»ã©ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚

# Flow Matching

CNFã‚’å®‰å®šã—ã¦å­¦ç¿’å¯èƒ½ãªFlow Matchingã«ã¤ã„ã¦è§£èª¬ã—ã¾ã™ã€‚
ä¸Šè¨˜ã®ã‚ˆã†ã«ã€æ™‚é–“å…¨ä½“ã®å­¦ç¿’ãŒå¿…è¦ã§ã‚ã‚‹ç‚¹ãŒã€CNFã®æ¬ ç‚¹ã¨è¨€ãˆã¾ã™ã€‚
ãã“ã§ã€CNFã‚’æ™‚åˆ»ã”ã¨ã«ã€å­¦ç¿’å¯èƒ½ã«ã™ã‚‹ãŸã‚ã«ã€Flow MatchingãŒã€é–‹ç™ºã•ã‚Œã¾ã—ãŸã€‚

ã¾ãšã€å¾®å°æ™‚å¤‰ãƒ™ã‚¯ãƒˆãƒ«å ´$u$ã®ODEã¯ã€ä»¥ä¸‹ã«ãªã‚Šã¾ã™ã€‚

$dx = u_t (x) dt $

$u_t(x)$ã¯ã€$u(t, x)$ã¨åŒæ§˜ã§ã™ã€‚åˆæœŸæ¡ä»¶$\phi_0 (x) = x$ã®ODEã®è§£ã¯ã€ç©åˆ†å†™åƒ$\phi_t$ã¨ãªã‚Šã¾ã™ã€‚$\phi_t(x)$ãŒæ™‚åˆ»$0$ã‹ã‚‰$t$ã¾ã§ãƒ™ã‚¯ãƒˆãƒ«å ´$u$ã«æ²¿ã£ã¦è¼¸é€ã•ã‚Œã‚‹ç‚¹$x$ã‚’è¡¨ç¾ã—ã¦ã„ã¾ã™ã€‚ã¾ãŸã€å¯†åº¦$p_t$ã¯ã€æ™‚åˆ»$0$ã‹ã‚‰æ™‚åˆ»$t$ã¾ã§$u$ã«æ²¿ã£ã¦è¼¸é€ã•ã‚Œã‚‹ç‚¹$x \sim p_0$ã®å¯†åº¦ã§ã™ã€‚
ãã—ã¦ã€æ™‚å¤‰å¯†åº¦$p_t$ã¯ã€$\partial p / \partial t = - \nabla \cdot (p_t u_t)$ã¨ã€åˆæœŸæ¡ä»¶$p_0$ã®æ¡ä»¶ä¸‹ã§ã€$p$ã¯$u$ã«ã‚ˆã‚‹ç¢ºç‡çµŒè·¯ã§ã€$u$ã¯$p$ã®ç¢ºç‡ãƒ•ãƒ­ãƒ¼ODEã¨ãªã‚Šã¾ã™ã€‚

ã“ã®ã¨ãã€Flow Matchingã¯ã€ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯$v_{\theta}(t, x)$ãŒã€æ™‚é–“ä¾å­˜ã®ãƒ™ã‚¯ãƒˆãƒ«å ´$u_t(x)$ã«å›å¸°ã™ã‚‹ã‚ˆã†ãªæå¤±ã‚’æŒã¡ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

$L_{FM}(\theta) = \rm{E}_{t\sim \mathcal{U}(0,1), x\sim p_t(x)} ||v_{\theta}(t, x) - u_t(x)||^2$

[Flow Matching for Generative Modeling](https://openreview.net/forum?id=PqvMRDCJT9t) ã§ã¯ã€æ­£è¦åˆ†å¸ƒã«ã‚ˆã‚‹ã‚¬ã‚¦ã‚¹ç¢ºç‡çµŒè·¯$p_t(x) = \mathcal{N}(x | u_t, \sigma_t^2)$ã‚’è€ƒãˆã¦ã„ã¾ã™ã€‚ãã‚Œã¯ã€ç©åˆ†å†™åƒãŒ$\phi_t(x) = \mu_t + \sigma_t x$ã‚’æº€ãŸã™ã¨ãã€ãƒ™ã‚¯ãƒˆãƒ«å ´ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã¨ã—ã¦ã„ã¾ã™ã€‚

$u_t(x) = \frac{\sigma_t^{\prime}}{\sigma_t} (x - \mu_t) + \mu_t^{\prime}$

Flow Matchingã«ã‚ˆã‚Šã€ã“ã®ãƒ™ã‚¯ãƒˆãƒ«å ´ã‚’å›å¸°ã™ã‚‹ã‚ˆã†ã«$v_{\theta}(t, x)$ã‚’å­¦ç¿’ã™ã‚‹ã“ã¨ã§ã€CNFã®å­¦ç¿’ã‚’å®‰å®šã—ã¦è¡Œãˆã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚


# Conditional Flow Matching

Flow matchingã¯ã€ã‚¬ã‚¦ã‚¹ç¢ºç‡çµŒè·¯ã‚’ä»®å®šã—ã¦ã„ã¾ã—ãŸã€‚ãã“ã§ã€ã‚¬ã‚¦ã‚¹åˆ†å¸ƒã®ä»®å®šã‚’ç·©å’Œã—ã€2ã¤ã®åˆ†å¸ƒé–“ã®æ¡ä»¶ä»˜ãç¢ºç‡çµŒè·¯(ODE Bridge)ã®å­¦ç¿’ã‚’å¯èƒ½ã«ã—ãŸã€Conditional Flow Mataching (CFM)ãŒææ¡ˆã•ã‚Œã¾ã—ãŸã€‚

æ½œåœ¨æ¡ä»¶å¤‰æ•°$z$ã«ãŠã„ã¦ã€æ½œåœ¨å¤‰æ•°ã«ã‚ˆã‚‹åˆ†å¸ƒ$q(z)$ã¨ç¢ºç‡çµŒè·¯$p_t(x|z)$ã«ã‚ˆã‚‹å‘¨è¾ºç¢ºç‡çµŒè·¯$p_t(x)$ã¯ã€ä»¥ä¸‹ã®å¼ã¨ãªã‚Šã¾ã™ã€‚

$p_t(x) = \int p_t(x|z)q(z)dz$

ã‚‚ã—ã€åˆæœŸæ¡ä»¶åˆ†å¸ƒ$p_0 (x|z)$ã‹ã‚‰ãƒ™ã‚¯ãƒˆãƒ«å ´$u_t(x|z)$ã«ã‚ˆã£ã¦ç¢ºç‡çµŒè·¯$p_t(x|z)$ãŒç”Ÿæˆã•ã‚Œã‚‹ã¨ã™ã‚‹ã¨ã€å‘¨è¾ºãƒ™ã‚¯ãƒˆãƒ«å ´$u_t(x)$ã¯ã€

$u_t(x) := \rm{E}_{q(z)} \frac{u_t(x|z)p_t(x|z)}{p_t(x)}$

ã¨ãªã‚‹ã€‚ãã—ã¦ã€å‘¨è¾ºãƒ™ã‚¯ãƒˆãƒ«å ´$u_t(x)$ã«ã‚ˆã£ã¦ã€åˆæœŸæ¡ä»¶$p_0(x)$ã‹ã‚‰å‘¨è¾ºç¢ºç‡çµŒè·¯$p_t(x)$ãŒç”Ÿæˆã•ã‚Œã¾ã™ã€‚
ãã®ãŸã‚ã€æ¡ä»¶ä»˜ãç¢ºç‡çµŒè·¯$p_t(x|z)$ã¨ãƒ™ã‚¯ãƒˆãƒ«å ´$u_t(x|x)$ã‹ã‚‰$u_t$ã‚’è¨ˆç®—ã—ãŸã„ãŒã€åˆ†æ¯ã®$p_t(x)$ã®è¨ˆç®—ã¯ç©åˆ†ã‚’å«ã¿å›°é›£ã§ã™ã€‚

ãã“ã§ã€CFMã®æå¤±ã‚’

$\rm{L}_{CFM}(\theta) = \rm{E}_{t, q(z), p_t(x|z)} ||v_{\theta}(t, x) - u_t(x|z)||^2$

ã¨ã—ãŸã¨ãã€ç‰¹å®šã®æ¡ä»¶ä¸‹ã§ã€

$\nabla \rm{L}_{CFM}(\theta) = \rm{L}_{FM}(\theta)$

ã§ã‚ã‚‹ã“ã¨ãŒè«–æ–‡ã§ç¤ºã•ã‚Œã¾ã—ãŸã€‚
ã¤ã¾ã‚Šã€æ¡ä»¶ä»˜ããƒ™ã‚¯ãƒˆãƒ«å ´$u_t(x|z)$ã‚’è¨ˆç®—ã§ãã‚‹ãªã‚‰ã€å‘¨è¾ºãƒ™ã‚¯ãƒˆãƒ«$u_t(x)$ã«å›å¸°ã™ã‚‹ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆ$v_{\theta}$ã‚’å­¦ç¿’ã§ãã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã—ãŸã€‚

ã“ã‚Œã‚’CNFã¨ã—ã€ä»¥ä¸‹ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ (è«–æ–‡ä¸­ Algorithm 1)ã§è¨ˆç®—ã•ã‚Œã¾ã™ã€‚

![](https://storage.googleapis.com/zenn-user-upload/eebf91be8324-20231207.png)


ã“ã‚Œã‚ˆã‚Šä¸‹ã®é …ç›®ã§ã¯ã€$q(z)$, $p_t(-, z)$, $u_t(-|z)$ã«ã‚ˆã£ã¦å®šç¾©ã•ã‚Œã‚‹æ§˜ã€…ãªCFMã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚


# Flow Matching from a Gauusian

[Flow Matching for Generative Modeling](https://openreview.net/forum?id=PqvMRDCJT9t) ã§èª¬æ˜ã•ã‚ŒãŸFlow Matchingã‚’CFMã®ç‰¹æ®Šãªã‚±ãƒ¼ã‚¹ã¨ã—ã¦ã®è§£é‡ˆã‚’èª¬æ˜ã—ã¾ã™ã€‚
ã“ã®è«–æ–‡ã§ã¯ã€$z = x_1$ã¨ã—ã€æ¨™æº–æ­£è¦åˆ†å¸ƒ$p_0(x|z) = \mathcal{N}(x; 0, 1)$ã‹ã‚‰ã€$p_1(x|z) = \mathcal{N}(x; x_1, \sigma^2)$ã¸ã®ç¢ºç‡çµŒè·¯ã¨è¨­å®šã—ã¦ã„ã¾ã™ã€‚

ã¤ã¾ã‚Šã€ç¢ºç‡çµŒè·¯ã¯ã€

$p_t(x|z) = \mathcal{N}(x | tx_1, (t \sigma - t + 1)^2)$

ã¨ãªã‚Šã€ãƒ™ã‚¯ãƒˆãƒ«å ´ã¯ã€

$u_t(x|z) = \frac{x_1 - (1-\sigma)x}{1 - (1 - \sigma)t}$

ã¨ãªã‚Šã¾ã™ã€‚

ä¸‹å›³ã¯ã€è«–æ–‡ä¸­ã®Figure 1ã§ã€Flow Matchingã®ã‚¤ãƒ¡ãƒ¼ã‚¸ã§ã™ã€‚ã‚¬ã‚¦ã‚¹åˆ†å¸ƒãŒãƒ‡ãƒ¼ã‚¿ã‚µãƒ³ãƒ—ãƒ«ã¸åˆ†æ•£ã‚’å°ã•ãã—ãªãŒã‚‰é·ç§»ã—ã¦ã„ã‚‹ç¢ºç‡çµŒè·¯ãŒè¦‹ãˆã¾ã™ã­ã€‚

![](https://storage.googleapis.com/zenn-user-upload/6e79e34c8494-20231207.png)


# Independet CFM

CFMã®åŸºæœ¬å½¢ã¨ã—ã¦ã€æ½œåœ¨å¤‰æ•°$z$ã‚’ã€åˆæœŸç‚¹$x_0$ã¨ã€ç›®æ¨™ç‚¹$x_1$ã§åŒå®šã—ã€$q(z) = q(x_0)q(x_1)$ã¨ã—ãŸI-CFMã‚’èª¬æ˜ã—ã¾ã™ã€‚
$x_0$ã¨$x_1$ã®é–“ã®ç¢ºç‡çµŒè·¯ã‚’ã‚¬ã‚¦ã‚¹åˆ†å¸ƒã®ç§»å‹•ã¨è€ƒãˆã‚‹ã¨ã€ä»¥ä¸‹ã®ç¢ºç‡çµŒè·¯ã«ãªã‚Šã¾ã™ã€‚

$p_t(x|z) = \mathcal{N}(x | tx_1 + (1 - t) x_0, \sigma^2)$

ãã—ã¦ã€ã“ã®ç¢ºç‡çµŒè·¯ã®å¹³å‡ã¨åˆ†æ•£ã‚’ãƒ™ã‚¯ãƒˆãƒ«å ´ã®å®šå¼(flow matchingã®é …ã«è¨˜è¼‰)ã«ã‚ã¦ã¯ã‚ã‚‹ã¨ã€ãƒ™ã‚¯ãƒˆãƒ«å ´ã¯ã€

$u_t(x|z) =  x1 - x0$

ã¨ãªã‚Šã¾ã™ã€‚ã‹ãªã‚Šã‚·ãƒ³ãƒ—ãƒ«ãªå½¢å¼ã«ãªã£ã¦ã„ã¾ã™ãŒã€ã“ã‚Œã«ã‚ˆã‚Š$p_t(x|z)$ã¯åŠ¹ç‡çš„ã«ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã§ãã€$u_t$ã¯åŠ¹ç‡çš„ã«è¨ˆç®—ã§ãã‚‹ãŸã‚ã€$\rm{L}_{CFM}$ã®å‹¾é…è¨ˆç®—ã‚‚åŠ¹ç‡çš„ã¨ã®ã“ã¨ã§ã™ã€‚

ä¸‹å›³ã¯ã€è«–æ–‡ä¸­ã®Figure 1ã§ã€I-CFMã®ã‚¤ãƒ¡ãƒ¼ã‚¸ã§ã™ã€‚å›ºå®šã®åˆ†æ•£ã®åˆ†å¸ƒãŒç§»å‹•ã—ã¦ã„ã‚‹äº‹ãŒã‚ã‹ã‚Šã¾ã™ã€‚ã“ã‚Œã‚’è¦‹ã‚‹ã¨ã€æ‹¡æ•£ãƒ¢ãƒ‡ãƒ«ã¨ç•°ãªã‚Šã€åˆ†å¸ƒé–“ã®ç§»å‹•ã‚’è¡Œã£ã¦ã„ã‚‹ã‚ˆã†ãªæ°—ãŒã—ã¾ã™ã­ã€‚ãã‚‚ãã‚‚ã€æ‹¡æ•£ãƒ¢ãƒ‡ãƒ«ã®ã‚ˆã†ã«ãƒã‚¤ã‚ºã‹ã‚‰ãƒã‚¤ã‚ºé™¤å»ã§ç”Ÿæˆã™ã‚‹ã‚ˆã‚Šã€ç‰¹å®šã®åˆ†å¸ƒã‹ã‚‰ç”Ÿæˆã—ãŸã»ã†ãŒåŠ¹ç‡è‰¯ã„æ°—ãŒã—ã¾ã™ã€‚ã©ãªã‚“ã§ã—ã‚‡ã†ã‹...

![](https://storage.googleapis.com/zenn-user-upload/c8b7ec11bd22-20231207.png)

I-CFMã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€ä»¥ä¸‹ã«ãªã‚Šã¾ã™ã€‚ã“ã‚Œã ã‘è¦‹ã‚‹ã¨ã€ã‹ãªã‚Šã‚·ãƒ³ãƒ—ãƒ«ã§ã™ã­ã€‚

![](https://storage.googleapis.com/zenn-user-upload/d02dd2a714f5-20231207.png)

# Optimal Transport CFM

ã¾ãšã€2-Wassersteinè·é›¢ã«ã‚ˆã‚‹æœ€é©è¼¸é€(OT)ã«é–¢ã—ã¦èª¬æ˜ã—ã¾ã™ã€‚ãã—ã¦ã€OTã‚’ç”¨ã„ã¦CFMã«é–¢ã—ã¦èª¬æ˜ã—ã¾ã™ã€‚

## 2-Wassersteinè·é›¢

æœ€é©è¼¸é€å•é¡Œã¯ã€ã‚ã‚‹æ¸¬åº¦ã‹ã‚‰åˆ¥ã®æ¸¬åº¦ã¸ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ã€ã‚³ã‚¹ãƒˆãŒæœ€å°åŒ–ã™ã‚‹ã‚ˆã†ã«æ±‚ã‚ã‚‹ã‚‚ã®ã§ã‚ã‚‹ã€‚è«–æ–‡ã§ã¯ã€2-Wassersteinè·é›¢ã‚’ç”¨ã„ã¦ãŠã‚Šã€åˆ†å¸ƒ$q_0$ã¨$q_1$ã®é–“ã®ã‚³ã‚¹ãƒˆ$c(x, y) = ||x - y||$ ã‚’ç”¨ã„ã¦ã€ä»¥ä¸‹ã®å¼ã§è¡¨ã•ã‚Œã¾ã™ã€‚


$\mathcal{W}(q_0, q_1)^2_2 = \rm{inf} \int_{\mathcal{X}} c(x, y)^2 d \pi (x, y)$

ãã—ã¦ã€2-Wassrsteinè·é›¢ã®å‹•çš„å½¢å¼ã¯ã€ã‚ã‚‹æ¸¬åº¦ã‚’ä»–ã®æ¸¬åº¦ã«å¤‰æ›ã™ã‚‹ãƒ™ã‚¯ãƒˆãƒ«å ´$u_t$ä¸Šã®æœ€é©åŒ–å•é¡Œã¨ã—ã¦ã‚‚å®šç¾©ã§ãã¾ã™ã€‚

$\mathcal{W}(q_0, q_1)^2_2 = \rm{inf} \int_{\rm{R}^d} \int^{1}_{0} p_t(x) ||u_t(x)||^2 dt dx$

L2æ­£å‰‡åŒ–ã‚’æŒã¤CNFãŒå‹•çš„æœ€é©è¼¸é€ã«è¿‘ä¼¼å¯èƒ½ãªã“ã¨ã¯è¨¼æ˜ã•ã‚Œã¦ã„ã¾ã™ãŒã€ã“ã®å¼ã®è¨ˆç®—ã«ã¯ã€å¤šãã®ç©åˆ†ã¨ãƒãƒƒã‚¯ãƒ—ãƒ­ãƒ‘ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãŒå¿…è¦ãªãŸã‚æ•°å€¤çš„ã«ã‚‚ã€åŠ¹ç‡çš„ã«ã‚‚å•é¡ŒãŒã‚ã‚Šã¾ã—ãŸã€‚ãã“ã§ã€CFMã¨ã—ã¦ã€ç›´æ¥ãƒ™ã‚¯ãƒˆãƒ«å ´ã‚’å›å¸°ã™ã‚‹ã“ã¨ã§ã€ã“ã‚Œã‚‰ã®å•é¡Œã‚’å›é¿ã™ã‚‹ã“ã¨ãŒææ¡ˆã•ã‚Œã¾ã—ãŸã€‚

## OT-CFM

ä¸Šè¨˜ã®2-Wassersteinè·é›¢ã‚’CFMã«å½“ã¦ã¯ã‚ã‚‹ãŸã‚ã€2-Wassersteinæœ€é©è¼¸é€å†™åƒ$\pi$ã‚’$q(z)$ã¨ã™ã‚‹ã“ã¨ãŒææ¡ˆã•ã‚Œã¾ã—ãŸã€‚

$q(z) := \pi (x_0, x_1)$

ã“ã‚Œã«ã‚ˆã‚Šã€$q_0$, $q_1$ã‹ã‚‰ã€ç‹¬ç«‹ã«ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã—ã¦ã„ãŸ$x_0$, $x_1$ã‚’ã€æœ€é©è¼¸é€å†™åƒã«ã‚ˆã£ã¦ã€åŒæ™‚ã«ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã—ã¾ã™ã€‚
I-CFMã«å¯¾ã—ã¦ã€ã“ã®ä¿®æ­£ã‚’è¡Œã£ãŸã‚‚ã®ãŒã€OT-CFMã«ãªã‚Šã¾ã™ã€‚

è«–æ–‡ã§ã¯ã€

>OT-CFMã¯ã€$q(x_0)$ã¨$q(x_1)$ã®é–“ã®é™çš„OTå†™åƒã¨ä¸­é–“æ™‚é–“ã‚¹ãƒ†ãƒƒãƒ—ã§æ¡ä»¶ä»˜ããƒ•ãƒ­ãƒ¼ã®å›å¸°ã®ã¿ã‚’ç”¨ã„ã¦ã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒªãƒ¼ï¼ˆæ™‚é–“ã”ã¨ã«å­¦ç¿’å¯èƒ½ï¼‰ãªå‹•çš„OTå•é¡Œã‚’è§£ã„ãŸæœ€åˆã®æ‰‹æ³•ã§ã‚ã‚‹ã€‚

ã¨ã®ã“ã¨ã§ã™ã€‚

ä¸‹å›³ã¯ã€è«–æ–‡ä¸­ã®Figure 1ã§ã€OT-CFMã®ã‚¤ãƒ¡ãƒ¼ã‚¸ã§ã™ã€‚I-CFMã¨ç•°ãªã‚Šã€æ™‚åˆ»$0$ã‹ã‚‰$1$ã®åˆ†å¸ƒã®ç§»å‹•ãŒOTã®ãŠã‹ã’ã§ã‚¹ãƒ ãƒ¼ã‚ºã«è¦‹ãˆã¾ã™ã€‚

![](https://storage.googleapis.com/zenn-user-upload/671c2e40a4e3-20231207.png)

å®Ÿéš›ã€è«–æ–‡ä¸­ã®å®Ÿé¨“ã§ã¯ã€ä¸‹å›³ã®ã‚ˆã†ã«ã‚ˆã‚ŠåŠ¹ç‡çš„ãªåˆ†å¸ƒã®ç§»å‹•ãŒã§ãã¦ã„ã¾ã™ã€‚ä¸‹å›³ã¯ã€moonã‹ã‚‰9ã¤ã®ã‚¬ã‚¦ã‚¹åˆ†å¸ƒã®ç”Ÿæˆã‚’è¡Œã£ã¦ã„ã¾ã™ãŒã€å·¦å´ã®I-CFMã‚ˆã‚Šã€å³å´ã®OT-CFMãŒæ˜ã‚‰ã‹ã«ã‚·ãƒ³ãƒ—ãƒ«ãªé·ç§»ã‚’è¡Œã£ã¦ã„ã¾ã™ã€‚

![](https://storage.googleapis.com/zenn-user-upload/7ed690f1dc10-20231207.png)

ä¸‹å›³ã¯ã€OT-CFMã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚

ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ä¸­ã«OTã®ãƒŸãƒ‹ãƒãƒƒãƒè¿‘ä¼¼ãŒå‡ºã¦ãã¾ã™ã€‚å¤§ããªãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã«ãŠã„ã¦ã€OTã«ãŠã‘ã‚‹è¼¸é€è¨ˆç”»$\pi$ã®è¨ˆç®—ã¨ä¿å­˜ã¯ã€å›°é›£ãªå ´åˆãŒã‚ã‚Šã€OTã®ãƒŸãƒ‹ãƒãƒƒãƒè¿‘ä¼¼ã‚’ä½¿ç”¨ã™ã‚‹ã®ãŒå®Ÿç”¨çš„ã§ã™ã€‚å®Ÿéš›ã€æ­£ç¢ºãªOTã®è§£ã«å¯¾ã—ã¦èª¤å·®ãŒç”Ÿã˜ã¾ã™ãŒã€å¤šãã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«é©å¿œå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚

å®Ÿéš›ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’è¦‹ã‚‹ã¨ã€å¤‰ã‚ã£ãŸã¨ã“ã‚ã¯ã€OTã®éƒ¨åˆ†ãã‚‰ã„ã‹ã¨æ€ã„ã¾ã™ã€‚

![](https://storage.googleapis.com/zenn-user-upload/7c7d8cd1eec4-20231207.png)



# SchrÃ¶dinge Bridge CFM

è«–æ–‡ä¸­ã«ã¯ã€ã‚·ãƒ¥ãƒ¬ãƒ‡ã‚£ãƒ³ã‚¬ãƒ¼Bridge(SB)ã«ã‚ˆã‚‹CFMã‚‚ã§ã¦ãã¾ã™ã€‚å‹æ‰‹ãªã‚¤ãƒ¡ãƒ¼ã‚¸ã§ã™ãŒã€I-CFMã¨OT-CFMã®ä¸­é–“ã«å½“ãŸã‚‹ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’æŒã£ã¦ã„ã¾ã™ãŒã€ç†è«–ãŒè¤‡é›‘ã§èª¬æ˜ãŒé›£ã—ã„ã®ã§çœãã¾ã™ã€‚ã±ã£ã¨ã¿ã€SB-CFMã‚ˆã‚Šã€OT-CFMã®ã»ã†ãŒç²¾åº¦ãŒè‰¯ã•ãã†ã§ã—ãŸã€‚ãŸã ã€[Schrodinger Bridges Beat Diffusion Models on Text-to-Speech Synthesis](https://huggingface.co/papers/2312.03491)ã¨ã„ã†è«–æ–‡ã‚‚ã§ã¦ã„ãŸã®ã§ã€æ¬¡å›ã®è¨˜äº‹ã‚’æ›¸ãéš›ã«ã—ã£ã‹ã‚Šç†è§£ã—ãŸã„ã¨æ€ã„ã¾ã™ã€‚ï¼ˆèª°ã‹æ›¸ã„ã¦ï¼ï¼ï¼‰

ã¡ãªã¿ã«ã§ã™ãŒã€SchrÃ¶dinge Bridgeã«é–¢ã—ã¦ã¯ã€ä»¥ä¸‹ã®è¨˜äº‹ãŒã¨ã¦ã‚‚å‚è€ƒã«ãªã‚Šã¾ã—ãŸã€‚ã™ã”ãè‰¯ã„è¨˜äº‹ã§ã™ï¼

- [Morpho Tech log - A Brief Survey of SchrÃ¶dinger Bridge (Part I)](https://techblog.morphoinc.com/entry/2023/09/12/100000)

# æ¯”è¼ƒ

æœ€å¾Œã«æ¯”è¼ƒçµæœã§ã™ã€‚
ä¸‹å›³ã¯ã€åˆ†å¸ƒã®é©åˆåº¦ï¼ˆä¸€è‡´åº¦ï¼Ÿï¼‰ã‚’ç¤ºã—ãŸ2-Wasserstein $\mathcal{W}^2_2$ã¨ã€æœ€é©è¼¸é€æ€§èƒ½(Normalized Path Energy)ã§æœ€é©è¼¸é€æ€§èƒ½ã‚’æ¯”è¼ƒã—ãŸã‚‚ã®ã§ã™ã€‚å€¤ãŒå°ã•ã„ã»ã©æ€§èƒ½ãŒã‚ˆã„ã§ã™ã€‚OT-CFMã¯ã€$\mathcal{W}^2_2$ã‚‚NPEã‚‚ã€è‰¯ã•ãã†ã§ã™ã€‚


![](https://storage.googleapis.com/zenn-user-upload/d1b0965ec0d2-20231207.png)

ã¾ãŸã€ä¸‹å›³ã®å·¦ã‚ˆã‚Šã€å­¦ç¿’æ™‚ã®æ¤œè¨¼ã‚»ãƒƒãƒˆã«å¯¾ã™ã‚‹èª¤å·®ã®åæŸã‚‚æ—©ã„ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ã€‚

![](https://storage.googleapis.com/zenn-user-upload/86fc1ad56589-20231207.png)

# ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¸Šã§ã©ã†è¨˜è¼‰ã™ã‚‹ã®ã‹ï¼Ÿ

ç†è«–ã°ã‹ã‚Šæ›¸ã„ã¦ã‚‚ã€ã¾ãã‚ã‹ã‚‰ãªã„ã®ã§ã€ã„ãã¤ã‹å®Ÿè£…ä¾‹ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

ã¾ãšã¯ã€CFMã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹éŸ³å£°åˆæˆãƒ¢ãƒ‡ãƒ«ã§ã‚ã‚‹[Matcha-TTS](https://github.com/shivammehta25/Matcha-TTS/blob/main/matcha/models/components/flow_matching.py)ã§ã™ã€‚ã“ã“ã§ã¯ã€$x_1$ãŒç›®æ¨™ã¨ãªã‚‹ãƒ‡ãƒ¼ã‚¿ã§ã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ€ã®å‡ºåŠ›ã§ã‚ã‚‹ãƒ¡ãƒ«ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ $mu$ã‚’flow matchingã§ã„ã„æ„Ÿã˜ã«å¤‰æ›ã—$x_1$ã«è¿‘ã¥ã‘ã‚‹ãŸã‚ã€$mu$ã¨ã„ã†å¼•æ•°ãŒã‚ã‚Šã¾ã™ã€‚

å®Ÿè£…ã‚’è¦‹ã‚‹ã¨ã€ãƒ©ãƒ³ãƒ€ãƒ ãª$z$ã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã—ã¦ã„ã¾ã™ãŒã€I-CFNã¨ã„ã†èªè­˜ã§ã‚ˆã„ã®ã§ã—ã‚‡ã†ã‹ã€‚ï¼ˆãŸã ã€[ä»–ã®CFMã®å®Ÿè£…](https://github.com/atong01/conditional-flow-matching/blob/21cd0c888186f6e2b76deb393800361b8a850e9b/examples/cifar10/train_cifar10.py#L147C13-L147C13)ã®åˆæœŸå€¤ã‚‚åŒæ§˜ã«ãªã£ã¦ã„ã¾ã—ãŸã€‚ï¼‰ã¾ãŸã€æ°—ã«ãªã‚‹ç‚¹ã¨ã—ã¦ã¯ã€ç¢ºç‡çµŒè·¯ã®å¹³å‡ã‚’è¨ˆç®—ã™ã‚‹éƒ¨åˆ†ã¨ã€ãƒ™ã‚¯ãƒˆãƒ«å ´ã‚’è¨ˆç®—ã™ã‚‹éƒ¨åˆ†ã«ã€`sigma_min`ãŒå…¥ã£ã¦ã„ã¾ã™ã€‚ãŸã ã€ã“ã®å€¤ã¯ã€ã‹ãªã‚Šå°ã•ã„($1e^{-4}$)ã¨ã‹ãªã®ã§ã€ç„¡è¦–ã—ã¦ã‚‚è‰¯ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€å®Ÿè£…ä¸Šå¿…è¦ãªã®ã§ã—ã‚‡ã†ã‹ã­...ã€€([ä»–ã®å®Ÿè£…](https://github.com/atong01/conditional-flow-matching/blob/main/runner/configs/model/otcfm.yaml)ã§ã¯ã€$0.1$ãªã©å‰²ã‚Šã¨å¤§ãã‚ã®å€¤ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆãŒã‚ã‚Šã¾ã—ãŸã€‚)

ã¾ãŸã€ç¢ºç‡çµŒè·¯ã‹ã‚‰ã€ãƒ‡ãƒ¼ã‚¿$x$ã‚’ã‚µãƒ³ãƒ—ãƒ«ã—ã¦ã„ãŸã¯ãšã§ã™ãŒã€ã“ã“ã§ã¯è¨ˆç®—ã›ãšã€ç›´æ¥ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã«å…¥åŠ›ã—ã¦ã„ã¾ã™ã€‚ã“ã¡ã‚‰ã‚‚å®Ÿè£…ãªã‚‰ã§ã¯ãªã®ã‹ãªã¨ã„ã†æ°—ãŒã—ã¾ã™ã€‚

```python:https://github.com/shivammehta25/Matcha-TTS/blob/c8d0d60f87147fe340f4627b84588e812e5fbb00/matcha/models/components/flow_matching.py#L89C5-L120C23
def compute_loss(self, x1, mask, mu, spks=None, cond=None):
        """Computes diffusion loss

        Args:
            x1 (torch.Tensor): Target
                shape: (batch_size, n_feats, mel_timesteps)
            mask (torch.Tensor): target mask
                shape: (batch_size, 1, mel_timesteps)
            mu (torch.Tensor): output of encoder
                shape: (batch_size, n_feats, mel_timesteps)
            spks (torch.Tensor, optional): speaker embedding. Defaults to None.
                shape: (batch_size, spk_emb_dim)

        Returns:
            loss: conditional flow matching loss
            y: conditional flow
                shape: (batch_size, n_feats, mel_timesteps)
        """
        b, _, t = mu.shape

        # random timestep
        t = torch.rand([b, 1, 1], device=mu.device, dtype=mu.dtype)
        # sample noise p(x_0)
        x0 = torch.randn_like(x1)

        # ç¢ºç‡çµŒè·¯ã®å¹³å‡è¨ˆç®—
        y = (1 - (1 - self.sigma_min) * t) * x0 + t * x1
        
        # ãƒ™ã‚¯ãƒˆãƒ«å ´ã®è¨ˆç®—
        u = x1 - (1 - self.sigma_min) * x0

        loss = F.mse_loss(self.estimator(y, mask, mu, t.squeeze(), spks), u, reduction="sum") / (
            torch.sum(mask) * u.shape[1]
        )
        return loss, y
```

ã“ã‚Œã‚’ã€OT-CFMã«æ”¹é€ ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚å®Ÿéš›å‹•ä½œã•ã›ã¦ã„ãªã„ã§ã™ãŒã€ãŠãã‚‰ãä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã¨æ€ã„ã¾ã™ã€‚æœ€é©è¼¸é€ã«ã¯ã€[POT: Python Optimal Transport](https://pythonot.github.io/)ã¨ã„ã†ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

```python
from functools import partial
import ot as pot

class OTCFM()
    def __init__(self, ot_method):
        if ot_method == "exact":
            self.ot_fn = pot.emd
        elif ot_method == "sinkhorn":
            self.ot_fn = partial(pot.sinkhorn, reg=reg)
        elif ot_method == "unbalanced":
            self.ot_fn = partial(pot.unbalanced.sinkhorn_knopp_unbalanced, reg=reg, reg_m=reg_m)
        elif ot_method == "partial":
            self.ot_fn = partial(pot.partial.entropic_partial_wasserstein, reg=reg)

    def get_map(self, x0, x1):
        """Compute the OT plan (wrt squared Euclidean cost) between a source and a target
        minibatch.

        Parameters
        ----------
        x0 : Tensor, shape (bs, *dim)
            represents the source minibatch
        x1 : Tensor, shape (bs, *dim)
            represents the source minibatch

        Returns
        -------
        p : numpy array, shape (bs, bs)
            represents the OT plan between minibatches
        """
        a, b = pot.unif(x0.shape[0]), pot.unif(x1.shape[0])
        if x0.dim() > 2:
            x0 = x0.reshape(x0.shape[0], -1)
        if x1.dim() > 2:
            x1 = x1.reshape(x1.shape[0], -1)
        x1 = x1.reshape(x1.shape[0], -1)
        M = torch.cdist(x0, x1) ** 2
        if self.normalize_cost:
            M = M / M.max()  # should not be normalized when using minibatches
        p = self.ot_fn(a, b, M.detach().cpu().numpy())
        return p
    def sample_map(self, pi, batch_size):
        r"""Draw source and target samples from pi  $(x,z) \sim \pi$

        Parameters
        ----------
        pi : numpy array, shape (bs, bs)
            represents the source minibatch
        batch_size : int
            represents the OT plan between minibatches

        Returns
        -------
        (i_s, i_j) : tuple of numpy arrays, shape (bs, bs)
            represents the indices of source and target data samples from $\pi$
        """
        p = pi.flatten()
        p = p / p.sum()
        choices = np.random.choice(pi.shape[0] * pi.shape[1], p=p, size=batch_size)
        return np.divmod(choices, pi.shape[1])

    def compute_loss(self, x1, mask, mu, spks=None, cond=None):
        """Computes diffusion loss

        Args:
            x1 (torch.Tensor): Target
                shape: (batch_size, n_feats, mel_timesteps)
            mask (torch.Tensor): target mask
                shape: (batch_size, 1, mel_timesteps)
            mu (torch.Tensor): output of encoder
                shape: (batch_size, n_feats, mel_timesteps)
            spks (torch.Tensor, optional): speaker embedding. Defaults to None.
                shape: (batch_size, spk_emb_dim)

        Returns:
            loss: conditional flow matching loss
            y: conditional flow
                shape: (batch_size, n_feats, mel_timesteps)
        """
        b, _, t = mu.shape

        # random timestep
        t = torch.rand([b, 1, 1], device=mu.device, dtype=mu.dtype)
        # sample noise p(x_0)
        x0 = torch.randn_like(x1)
        
        # OTã‚’ç”¨ã„ã¦ã€x0, x1ã‚’ã‚µãƒ³ãƒ—ãƒ«
        pi = self.get_map(x0, x1)
        i_arr, j_arr = self.sample_map(pi, x0.shape[0])
        x0, x1 = x0[i_arr], x1[j_arr]

        y = (1 - (1 - self.sigma_min) * t) * x0 + t * x1
        u = x1 - (1 - self.sigma_min) * x0

        loss = F.mse_loss(self.estimator(y, mask, mu, t.squeeze(), spks), u, reduction="sum") / (
            torch.sum(mask) * u.shape[1]
        )
        return loss, y
```

# æœ€å¾Œã«

ä»Šå›ã¯ã€Flow Matchingã‚’ã‚ˆã‚ŠåŠ¹ç‡çš„ã«ã—ãŸã€OT-CFMã«ã¤ã„ã¦è§£èª¬ã—ã¾ã—ãŸã€‚å€‹äººçš„ã«ã€æ•°å¼ãŒå¤šãé›£ã—ã„ãªï½ã¨æ€ã„ãªãŒã‚‰ã‚‚ã€ä»Šå¾Œä½¿ãˆã‚‹æŠ€è¡“ã ã¨æ€ã„ã€è¨˜äº‹ã«ã—ã¦ã¿ã¾ã—ãŸã€‚ã“ã®è¨˜äº‹ã§ã€Flow Matchingã®ç†è§£ã®æ‰‹åŠ©ã‘ã«ãªã‚Œã°ã¨æ€ã„ã¾ã™ã€‚

ä»Šå¾Œã¯ã€ã‚·ãƒ¥ãƒ¬ãƒ‡ã‚£ãƒ³ã‚¬ãƒ¼Bridgeã«é–¢ã™ã‚‹è¨˜äº‹ã‹ã€å®Ÿéš›ã«OT-CFMã‚’ä½¿ç”¨ã—ãŸéŸ³å£°åˆæˆãªã©ã®è¨˜äº‹ã‚’ä½œæˆã§ãã‚Œã°ã¨æ€ã£ã¦ã„ã¾ã™ã€‚

---

æœ€å¾Œã«å®£ä¼ã«ãªã‚Šã¾ã™ãŒã€æ©Ÿæ¢°å­¦ç¿’ã§ãƒ“ã‚¸ãƒã‚¹ã®æˆé•·ã‚’åŠ é€Ÿã™ã‚‹ãŸã‚ã«ã€[Fusic](https://fusic.co.jp/)ã®æ©Ÿæ¢°å­¦ç¿’ãƒãƒ¼ãƒ ãŒãŠæ‰‹ä¼ã„ã—ã¦ã„ã¾ã™ã€‚æ©Ÿæ¢°å­¦ç¿’ã®PoCã‹ã‚‰é‹ç”¨ã¾ã§ã€ã™ã¹ã¦ã®å ´é¢ã§ã‚µãƒãƒ¼ãƒˆã—ãŸå®Ÿç¸¾ãŒã‚ã‚Šã¾ã™ã€‚ã‚‚ã—ã€å›°ã£ã¦ã„ã‚‹æ–¹ãŒã„ã¾ã—ãŸã‚‰ã€ãœã²[Fusic](https://fusic.co.jp/)ã«ã”ç›¸è«‡ãã ã•ã„ã€‚[ãŠå•ã„åˆã‚ã›](https://fusic.co.jp/contact/)ã‹ã‚‰æ°—è»½ã«ã”é€£çµ¡ã„ãŸã ã‘ã¾ã™ãŒã€[Twitterã®DM](https://twitter.com/kwashizzz)ã‹ã‚‰ã§ã‚‚å¤§æ­“è¿ã§ã™ï¼


# å‚è€ƒæ–‡çŒ®
- [Normalizing Flowå…¥é–€ ç¬¬1å› å¤‰åˆ†æ¨è«–](https://tatsy.github.io/blog/posts/2020/2020-12-30-normalizing_flow%E5%85%A5%E9%96%80_%E7%AC%AC1%E5%9B%9E/)
- [Normalizing Flowå…¥é–€ ç¬¬2å› Planar Flow](https://tatsy.github.io/blog/posts/2021/2021-01-03-normalizing_flow%E5%85%A5%E9%96%80_%E7%AC%AC2%E5%9B%9E/)
- [Normalizing Flowå…¥é–€ ç¬¬7å› Neural ODEã¨FFJORD](https://tatsy.github.io/blog/posts/2021/2021-01-11-normalizing_flow%E5%85%A5%E9%96%80_%E7%AC%AC7%E5%9B%9E/)
